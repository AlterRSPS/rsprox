package net.rsprox.proxy.binary.credentials

import com.github.michaelbull.logging.InlineLogger
import net.rsprox.cache.util.atomicWrite
import java.nio.file.LinkOption
import java.nio.file.Path
import kotlin.io.path.exists
import kotlin.io.path.readLines

public class BinaryCredentialsStream(
    private val path: Path,
) {
    public fun parse(): List<BinaryCredentials> {
        if (!path.exists(LinkOption.NOFOLLOW_LINKS)) {
            return emptyList()
        }
        val list = mutableListOf<BinaryCredentials>()
        val queue = ArrayDeque(path.readLines(Charsets.UTF_8))
        while (queue.isNotEmpty()) {
            list += parseCredentials(queue) ?: continue
        }
        return list
    }

    private fun parseCredentials(queue: ArrayDeque<String>): BinaryCredentials? {
        var name: String? = null
        var userId: Long? = null
        var userHash: Long? = null

        while (queue.isNotEmpty()) {
            val line = queue.removeFirst()
            if (line.isEmpty() || line.startsWith('#')) {
                continue
            }
            when {
                line.startsWith(NAME_KEY) -> {
                    check(name == null) {
                        "Name already assigned: $name, $line"
                    }
                    name = line.substringAfter(NAME_KEY)
                }
                line.startsWith(ID_KEY) -> {
                    check(userId == null) {
                        "User id already assigned: $userId, $line"
                    }
                    userId = line.substringAfter(ID_KEY).toLong()
                }
                line.startsWith(HASH_KEY) -> {
                    check(userHash == null) {
                        "User hash already assigned: $userHash, $line"
                    }
                    userHash = line.substringAfter(HASH_KEY).toLong()
                }
                else -> {
                    logger.warn { "Unknown credentials token: $line" }
                }
            }
            if (name == null || userId == null || userHash == null) {
                continue
            }
            return BinaryCredentials(name, userId, userHash)
        }
        check(name == null) {
            "EOF after parsing name"
        }
        check(userId == null) {
            "EOF after parsing user id"
        }
        check(userHash == null) {
            "EOF after parsing user hash"
        }
        return null
    }

    public fun write(credentialsList: List<BinaryCredentials>) {
        val file =
            buildString {
                writeBinaryCredentialsHeader(this)
                for (credentials in credentialsList) {
                    writeCredentialsEntry(this, credentials)
                    // Append an empty line between each credentials entry
                    if (credentials != credentialsList.last()) {
                        appendLine()
                    }
                }
            }
        path.atomicWrite(file)
    }

    private fun writeBinaryCredentialsHeader(builder: StringBuilder) {
        builder.appendLine("#DO NOT SHARE THIS FILE WITH ANYONE!")
        builder.appendLine("#This file is automatically generated. Do not edit it!")
        builder.appendLine("#These credentials can be used to delete binaries which")
        builder.appendLine("#have been uploaded to the public archive.")
        builder.appendLine("#These credentials do not affect your account security!")
        builder.appendLine("#The binaries themselves contain a SHA-256 hash of the")
        builder.appendLine("#user id and user hash values and cannot be reversed")
        builder.appendLine("#to the original components.")
        builder.appendLine()
    }

    private fun writeCredentialsEntry(
        builder: StringBuilder,
        credentials: BinaryCredentials,
    ) {
        builder.append(NAME_KEY).append(credentials.displayName).appendLine()
        builder.append(ID_KEY).append(credentials.userId).appendLine()
        builder.append(HASH_KEY).append(credentials.userHash).appendLine()
    }

    private companion object {
        private val logger = InlineLogger()
        private const val NAME_KEY: String = "user.name="
        private const val ID_KEY: String = "user.id="
        private const val HASH_KEY: String = "user.hash="
    }
}
